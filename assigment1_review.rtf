{\rtf1\ansi\ansicpg1252\cocoartf2636
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;\f2\fmodern\fcharset0 Courier;
\f3\fswiss\fcharset0 Helvetica-Oblique;}
{\colortbl;\red255\green255\blue255;\red74\green80\blue93;\red30\green33\blue39;\red184\green93\blue213;
\red81\green158\blue235;\red155\green162\blue177;\red197\green136\blue84;\red72\green168\blue181;\red108\green114\blue126;
\red136\green185\blue102;\red222\green180\blue104;}
{\*\expandedcolortbl;;\csgenericrgb\c29020\c31373\c36471;\csgenericrgb\c11765\c12941\c15294;\csgenericrgb\c72157\c36471\c83529;
\csgenericrgb\c31765\c61961\c92157;\csgenericrgb\c60784\c63529\c69412;\csgenericrgb\c77255\c53333\c32941;\csgenericrgb\c28235\c65882\c70980;\csgenericrgb\c42353\c44706\c49412;
\csgenericrgb\c53333\c72549\c40000;\csgenericrgb\c87059\c70588\c40784;}
\paperw11900\paperh16840\margl1440\margr1440\vieww26100\viewh13840\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \

\fs72 Question-1
\fs24 \
\
\

\f1\b\fs36 \ul My Solution for question 1:
\f0\b0 \ulnone \

\fs24 \
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f2\fs26 \cf2 \cb3 #question 1\
\
# function that will execute in every dfs call which checks for a river in all 4 directions\
\cf4 def \cf5 dfs\cf6 (\cf7 grid\cf6 , \cf7 i\cf6 , \cf7 j\cf6 , \cf7 n\cf6 , \cf7 m\cf6 ):\
\
    \cf4 if \cf7 i\cf6 <\cf7 0 \cf4 or \cf7 j\cf6 <\cf7 0 \cf4 or \cf7 i\cf6 >=\cf7 n \cf4 or \cf7 j\cf6 >=\cf7 m \cf4 or \cf7 grid\cf6 [\cf7 i\cf6 ][\cf7 j\cf6 ] == \cf7 1\cf6 :\
\
        \cf4 return \cf7 0\
\
    grid\cf6 [\cf7 i\cf6 ][\cf7 j\cf6 ] =\cf7 1\
\
    \cf6 left = \cf5 dfs\cf6 (\cf7 grid\cf6 , \cf7 i\cf6 , \cf7 j\cf6 -\cf7 1\cf6 , \cf7 n\cf6 , \cf7 m\cf6 )\
\
    right = \cf5 dfs\cf6 (\cf7 grid\cf6 , \cf7 i\cf6 , \cf7 j\cf6 +\cf7 1\cf6 , \cf7 n\cf6 , \cf7 m\cf6 )\
\
    up = \cf5 dfs\cf6 (\cf7 grid\cf6 , \cf7 i\cf6 -\cf7 1\cf6 , \cf7 j\cf6 , \cf7 n\cf6 , \cf7 m\cf6 )\
\
    down = \cf5 dfs\cf6 (\cf7 grid\cf6 , \cf7 i\cf6 +\cf7 1\cf6 , \cf7 j\cf6 , \cf7 n\cf6 , \cf7 m\cf6 )\
\
    \cf4 return \cf7 1 \cf6 +left + right + up + down\
\
\cf2 #function to find size of biggest river\
\cf4 def \cf5 size_of_biggest_river\cf6 (\cf7 grid\cf6 ):\
\
    n,m = \cf8 len\cf6 (\cf7 grid\cf6 ), \cf8 len\cf6 (\cf7 grid\cf6 [\cf7 0\cf6 ])\
\
    biggest_size = \cf7 0\
\
    \cf4 for \cf6 i \cf4 in \cf8 range\cf6 (n):\
\
        \cf4 for \cf6 j \cf4 in \cf8 range\cf6 (m):\
\
            \cf4 if \cf7 grid\cf6 [i][j] == \cf7 0\cf6 :\
\
                biggest_size = \cf8 max\cf6 (biggest_size, \cf5 dfs\cf6 (\cf7 grid\cf6 ,i,j,n,m))\
\
    \cf4 return \cf6 biggest_size\
\
grid = [ [\cf7 0\cf6 ,\cf7 1\cf6 ,\cf7 0\cf6 ,\cf7 1\cf6 ,\cf7 1\cf6 ], [\cf7 1\cf6 , \cf7 1\cf6 , \cf7 0\cf6 , \cf7 0\cf6 , \cf7 0\cf6 ], [\cf7 1\cf6 , \cf7 1\cf6 , \cf7 1\cf6 , \cf7 1\cf6 , \cf7 0\cf6 ], [\cf7 1\cf6 , \cf7 1\cf6 , \cf7 1\cf6 , \cf7 0\cf6 , \cf7 0\cf6 ] ]\
\
\cf8 print\cf6 (\cf5 size_of_biggest_river\cf6 (grid))\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \

\f1\b\fs36 Approach
\f0\b0  - Using DFS
\fs24 \
\

\fs28 Step-1: First, I created a function that accepts parameter grid\
Step-2: I iterated through the grid and whenever I found \'910\'92  that is water, I tried to check for its adjacent sides by making DFS function call\
Step-3: In this process, I updated the 
\f3\i biggest_size  
\f0\i0 as it is my final result (biggest Island)\
Step-4: In DFS function, I checked the base cases like out of bound cases and summed up the result of all four direction and returned the result.\
Step-5: While going through this process, ignorer to avoid multiple recursive call, I am setting grid[I][j] = 1.\
Step-5: Finally, after all iterations completed, we get our biggest size island and printed it.
\fs24 \
\

\f1\b\fs36 Time Complexity:  O(n*m)\
Space Complexity: O(1)  
\f0\b0\fs28 (Auxiliary space used for recursive calls)\

\fs24 \
\
\

\f1\b\fs36 \ul Mahesh's Solution for Question-1
\f0\b0\fs24 \ulnone \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f2\fs26 \cf4 \cb3 def \cf5 dfs\cf6 (\cf7 l\cf6 ,\cf7 n\cf6 ,\cf7 m\cf6 ,\cf7 i\cf6 ,\cf7 j\cf6 ):\
    \cf4 if \cf7 i\cf6 >=\cf7 n \cf4 or \cf7 j\cf6 >=\cf7 m \cf4 or \cf7 i\cf6 <\cf7 0 \cf4 or \cf7 j\cf6 <\cf7 0 \cf4 or \cf7 l\cf6 [\cf7 i\cf6 ][\cf7 j\cf6 ]==\cf7 1\cf6 :\
        \cf4 return \cf7 0\
    l\cf6 [\cf7 i\cf6 ][\cf7 j\cf6 ]=\cf7 1\
    \cf6 down=\cf5 dfs\cf6 (\cf7 l\cf6 ,\cf7 n\cf6 ,\cf7 m\cf6 ,\cf7 i\cf6 +\cf7 1\cf6 ,\cf7 j\cf6 )\
    right=\cf5 dfs\cf6 (\cf7 l\cf6 ,\cf7 n\cf6 ,\cf7 m\cf6 ,\cf7 i\cf6 ,\cf7 j\cf6 +\cf7 1\cf6 )\
    left=\cf5 dfs\cf6 (\cf7 l\cf6 ,\cf7 n\cf6 ,\cf7 m\cf6 ,\cf7 i\cf6 -\cf7 1\cf6 ,\cf7 j\cf6 )\
    up=\cf5 dfs\cf6 (\cf7 l\cf6 ,\cf7 n\cf6 ,\cf7 m\cf6 ,\cf7 i\cf6 ,\cf7 j\cf6 -\cf7 1\cf6 )\
    \cf4 return \cf6 left+right+down+up+\cf7 1\
\
\cf4 def \cf5 solve\cf6 (\cf7 l\cf6 ):\
    res=\cf7 0\cf6 ;\
    n=\cf8 len\cf6 (\cf7 l\cf6 )\
    m=\cf8 len\cf6 (\cf7 l\cf6 [\cf7 0\cf6 ])\
    \cf4 for \cf6 i \cf4 in \cf8 range\cf6 (n):\
        \cf4 for \cf6 j \cf4 in \cf8 range\cf6 (m):\
            \cf9 ans\cf6 =\cf7 0\
            \cf4 if \cf7 l\cf6 [i][j]==\cf7 0\cf6 :\
                ans=\cf5 dfs\cf6 (\cf7 l\cf6 ,n,m,i,j)\
                \cf4 if \cf6 ans>res:\
                    res=ans\
    \cf4 return \cf6 res\
\
\cf4 def \cf5 main\cf6 ():\
    \cf9 l\cf6 =[[\cf7 0\cf6 ,\cf7 1\cf6 ,\cf7 0\cf6 ,\cf7 1\cf6 ,\cf7 1\cf6 ],\
       [\cf7 1\cf6 ,\cf7 1\cf6 ,\cf7 0\cf6 ,\cf7 0\cf6 ,\cf7 0\cf6 ],\
       [\cf7 1\cf6 ,\cf7 1\cf6 ,\cf7 1\cf6 ,\cf7 1\cf6 ,\cf7 0\cf6 ],\
       [\cf7 1\cf6 ,\cf7 1\cf6 ,\cf7 1\cf6 ,\cf7 0\cf6 ,\cf7 0\cf6 ]\
\
       \cf8 print\cf6 (\cf5 solve\cf6 (l))\
\
    \cf4 if \cf6 __name__==\cf10 "__main__"\cf6 :\
        \cf5 main\cf6 ()\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \
\

\f1\b\fs36 Review on above solution: \
-
\fs28  
\f0\b0 Mahesh\'92s Solution is similar to my approach.\
\
\

\f1\b\fs36 Purushotham\'92s Solution for Question 1
\f0\b0\fs24 \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f2\fs26 \cf4 \cb3 def \cf5 dfs\cf6 (\cf7 node\cf6 , \cf7 grid\cf6 ):\
    x, y = \cf7 node\
    grid\cf6 [x][y] = \cf7 1\
    \cf6 size = \cf7 0\
    \cf6 n = \cf8 len\cf6 (\cf7 grid\cf6 )\
    m = \cf8 len\cf6 (\cf7 grid\cf6 [\cf7 0\cf6 ])\
\
    \cf4 for \cf6 dx, dy \cf4 in \cf6 [(-\cf7 1\cf6 , \cf7 0\cf6 ), (\cf7 1\cf6 , \cf7 0\cf6 ), (\cf7 0\cf6 , \cf7 1\cf6 ), (\cf7 0\cf6 ,-\cf7 1\cf6 )]:\
        new_x, new_y = x + dx, y+dy\
        \cf4 if \cf7 0 \cf6 <= new_x < n \cf4 and \cf7 0 \cf6 <= new_y < m \cf4 and \cf7 grid\cf6 [new_x][new_y] == \cf7 0\cf6 :\
            size += \cf5 dfs\cf6 ((new_x, new_y), \cf7 grid\cf6 )\
    \cf4 return \cf6 size + \cf7 1\
\
\
\cf4 def \cf5 find_max_path\cf6 (\cf7 grid\cf6 ):\
    ans = \cf7 0\
    \cf6 n = \cf8 len\cf6 (\cf7 grid\cf6 )\
    m = \cf8 len\cf6 (\cf7 grid\cf6 [\cf7 0\cf6 ])\
    \cf4 for \cf6 i \cf4 in \cf8 range\cf6 (n):\
        \cf4 for \cf6 j \cf4 in \cf8 range\cf6 (m):\
            \cf4 if \cf7 grid\cf6 [i][j] == \cf7 0\cf6 :\
                ans = \cf8 max\cf6 (ans, \cf5 dfs\cf6 ((i, j), \cf7 grid\cf6 ))\
    \cf4 return \cf6 ans\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \
\

\f1\b\fs36 Review on above Solution:
\f0\b0\fs24 \
\

\fs28 - The approach is similar to me but that implementation of checking in all four direction in dis function is different.\
- In above code, all directions are checked by iterating the directions in a list.
\fs24 \
\
\

\fs72 Question-2
\fs24 \
\

\f1\b\fs36 My Solution to Question-2:
\f0\b0\fs24 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f2\fs26 \cf2 \cb3 #question 2\
\
\cf4 class \cf11 Logger\cf6 :\
\
    \cf4 def \cf5 __init__\cf6 (\cf4 self\cf6 ):\
\
        \cf4 self\cf6 .msg_dict = \{\}\
\
    \cf4 def \cf5 shouldPrintMessage\cf6 (\cf4 self\cf6 , \cf7 timestamp\cf6 , \cf7 message\cf6 ):\
\
        \cf4 if \cf7 message \cf4 not in self\cf6 .msg_dict \cf4 or  \cf6 (\cf4 self\cf6 .msg_dict[\cf7 message\cf6 ] + \cf7 10 \cf6 <= \cf7 timestamp\cf6 ):\
\
            \cf4 self\cf6 .msg_dict[\cf7 message\cf6 ] = \cf7 timestamp\
\
            \cf4 return True\
\
        else\cf6 :\
\
            \cf4 return False\
\
\cf6 logger = \cf5 Logger\cf6 ()\
\
\cf8 print\cf6 (logger.\cf5 shouldPrintMessage\cf6 (\cf7 4\cf6 , \cf10 "foo"\cf6 ))\
\
\cf8 print\cf6 (logger.\cf5 shouldPrintMessage\cf6 (\cf7 3\cf6 , \cf10 "foo"\cf6 ))\
\
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \

\f1\b\fs36 Approach - Basic implementation
\f0\b0\fs24 \
\

\fs28 - Initialise the empty dictionary in 
\f3\i __init__
\f0\i0  function of Logger class\
- As the messages the coming to input stream, 
\f3\i shouldPrintMessage
\f0\i0  function is called, it accepts two parameters timestamp and message. \
- If the message is coming for 1st time, update the message in dictionary by timestamp and return true.\
- If not, we have to check whether the previous instance of same message came before 10 sec\
- If the current message came within 10 sec difference then return false\
- Else update dictionary and return true
\fs24 \
\

\f1\b\fs36 \
Mahesh\'92s Solution for Question 2:
\f0\b0\fs24 \
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f2\fs26 \cf4 \cb3 class \cf11 logger\cf6 :\
    \cf4 def \cf5 __init__\cf6 (\cf4 self\cf6 ):\
        \cf4 self\cf6 .dict=\{\}\
        \cf4 self\cf6 .log=[\cf10 "null"\cf6 ]\
    \cf4 def \cf5 ShouldPrint\cf6 (\cf4 self \cf6 ,\cf7 timestamp \cf6 ,\cf7 message\cf6 ):\
\
        \cf4 if \cf7 message \cf4 in self\cf6 .dict.\cf5 keys\cf6 ():\
            \cf4 if self\cf6 .dict[\cf7 message\cf6 ]+\cf7 10\cf6 <=\cf7 timestamp\cf6 :\
                \cf2 #self.dict[message]=timestamp\
                \cf4 self\cf6 .log.\cf5 append\cf6 (\cf4 True\cf6 )\
            \cf4 else\cf6 :\
                \cf4 self\cf6 .log.\cf5 append\cf6 (\cf4 False\cf6 )\
        \cf4 else\cf6 :\
            \cf4 self\cf6 .dict[\cf7 message\cf6 ]=\cf7 timestamp\
            \cf4 self\cf6 .log.\cf5 append\cf6 (\cf4 True\cf6 )\
\
\cf4 def \cf5 main\cf6 ():\
    query=\cf5 logger\cf6 ()\
\
    l1=[[\cf7 1\cf6 ,\cf10 "foo"\cf6 ],[\cf7 2\cf6 ,\cf10 "bar"\cf6 ],[\cf7 3\cf6 ,\cf10 "foo"\cf6 ],[\cf7 8\cf6 ,\cf10 "bar"\cf6 ],[\cf7 10\cf6 ,\cf10 "foo"\cf6 ],[\cf7 11\cf6 ,\cf10 "foo"\cf6 ]]\
\
    \cf4 for \cf6 i \cf4 in \cf6 l1:\
        query.\cf5 ShouldPrint\cf6 (i[\cf7 0\cf6 ],i[\cf7 1\cf6 ])\
\
\
    \cf8 print\cf6 (query.log)\
\
\
\cf4 if \cf6 __name__==\cf10 "__main__"\cf6 :\
    \cf5 main\cf6 ()\
\
\
\
\cf8 print\cf6 (\cf7 6 \cf6 + \cf7 5 \cf6 - \cf7 4 \cf6 * \cf7 3 \cf6 / \cf7 2 \cf6 % \cf7 1\cf6 )\
\
\cf8 print\cf6 (\cf7 3\cf6 ==\cf7 3.0\cf6 )\
\
tup=(\cf7 1\cf6 ,\cf7 3\cf6 ,\cf7 1\cf6 ,\cf7 2\cf6 ,\cf7 3\cf6 ,\cf7 4\cf6 ,\cf7 3\cf6 ,\cf7 2\cf6 ,\cf7 1\cf6 )\
\cf2 # tup.sort()   #give error\
\cf8 print\cf6 (\cf8 sorted\cf6 (tup))\
\cf8 print\cf6 (tup)\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \

\f1\b\fs36 \
Review on above solution: 
\f0\b0\fs24 \
\
-
\fs28  The approach is same, but the only difference is above code taking the input streaming messages in the form of list\
- solutions are storing in a list for every query.
\fs24 \
\

\f1\b\fs36 Purushotham\'92s Solution for Question 2:
\f0\b0\fs24 \
\
\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f2\fs26 \cf4 \cb3 class \cf11 Logger\cf6 :\
\
    \cf4 def \cf5 __init__\cf6 (\cf4 self\cf6 ):\
\
        \cf4 self\cf6 .msg_dict = \{\}\
\
    \cf4 def \cf5 canPrintMessage\cf6 (\cf4 self\cf6 , \cf7 timestamp\cf6 , \cf7 msg\cf6 ):\
\
        \cf4 if \cf7 msg \cf4 not in self\cf6 .msg_dict:\
\
            \cf4 self\cf6 .msg_dict[\cf7 msg\cf6 ]=\cf7 timestamp\
\
            \cf4 return True\
\
        elif \cf7 timestamp\cf6 -\cf4 self\cf6 .msg_dict[\cf7 msg\cf6 ] >= \cf7 10\cf6 :\
\
            \cf4 self\cf6 .msg_dict[\cf7 msg\cf6 ]=\cf7 timestamp\
\
            \cf4 return True\
\
        else\cf6 :\
\
            \cf4 return False\
        \
\cf6 logger = \cf5 Logger\cf6 ()\
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \cb1 \
\

\f1\b\fs36 Review on above code:
\f0\b0\fs24 \
\

\fs28 - The approach and implementation is same as mine.
\fs24 \
}